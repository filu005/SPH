#ifndef PERLIN_H
#define PERLIN_H

#define _CRT_RAND_S
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>

#include <memory>


namespace perlin
{

	class Noise1D
	{
	public:

		Noise1D(int* indicies, float* gradients, float positionOffset)
			: m_indicies(indicies),
			m_positionOffset(positionOffset),
			m_gradients(gradients) {}

		~Noise1D()
		{
			delete m_indicies;
			delete m_gradients;
		}

		float generate(float x) const
		{
			x += m_positionOffset;

			int xCoord = floor(x);


			/*
			Using:

			a --x----- b

			---> x
			*/

			float offset = x - xCoord;

			int a = xCoord;
			int b = xCoord + 1;

			float aGrad = getGradient(a);
			float bGrad = getGradient(b);

			float aContrib = offset * aGrad;
			float bContrib = (offset - 1) * bGrad;

			float param = 3 * offset * offset - 2 * offset * offset * offset;

			return (1 - param) * aContrib + param * bContrib;
		}

		float getGradient(int x) const
		{
			/*
			Offsets as generated by the following python code:

			import random

			values = [ str( x ) for x in range( 0, 256 ) ]

			random.seed( 0 )
			random.shuffle( values )

			print "{ %s }" % ", ".join( values )

			*/

			int index = x & 255;
			return m_gradients[m_indicies[index]];
		}


	private:

		int* m_indicies;
		float m_positionOffset;
		float* m_gradients;

	};

	template< typename T >
	class Point2
	{
	public:

		Point2() {};
		Point2(T _x, T _y) : x(_x), y(_y) {}

		T dot(const Point2< T >& other) const
		{
			return x * other.x + y * other.y;
		}

		T lengthSq() const
		{
			return x * x + y * y;
		}

		Point2< T > operator-(const Point2& other) const
		{
			return Point2< T >(x - other.x, y - other.y);
		}

		Point2< T > operator+(const Point2& other) const
		{
			return Point2< T >(x + other.x, y + other.y);
		}

		template< typename S >
		Point2< T > operator*(const S& scalar) const
		{
			return Point2< T >(x * scalar, y * scalar);
		}

		T x;
		T y;
	};

	typedef Point2< int > IntPoint2;
	typedef Point2< float > FloatPoint2;

	class Noise2D
	{
	public:

		Noise2D(int* indicies, FloatPoint2* gradients, FloatPoint2& positionOffset)
			: m_indicies(indicies),
			m_positionOffset(positionOffset),
			m_gradients(gradients) {}

		~Noise2D()
		{
			delete m_indicies;
			delete m_gradients;
		}


		float generate(float x, float y) const
		{
			x += m_positionOffset.x;
			y += m_positionOffset.y;

			const int xCoord = floor(x);
			const int yCoord = floor(y);

			/*
			Using:

			d ---------- c
			|            |
			|  . (x,y)   |
			y     |            |
			^     |            |
			|     a ---------- b
			|
			---> x

			*/

			const IntPoint2 a(xCoord, yCoord);
			const IntPoint2 b(xCoord + 1, yCoord);
			const IntPoint2 c(xCoord + 1, yCoord + 1);
			const IntPoint2 d(xCoord, yCoord + 1);

			const FloatPoint2 aGrad = getGradient(a);
			const FloatPoint2 bGrad = getGradient(b);
			const FloatPoint2 cGrad = getGradient(c);
			const FloatPoint2 dGrad = getGradient(d);

			float xOffset = x - xCoord;
			float yOffset = y - yCoord;

			const FloatPoint2 aOffset(xOffset, yOffset);
			const FloatPoint2 bOffset(xOffset - 1, yOffset);
			const FloatPoint2 cOffset(xOffset - 1, yOffset - 1);
			const FloatPoint2 dOffset(xOffset, yOffset - 1);

			float aContrib = aGrad.dot(aOffset);
			float bContrib = bGrad.dot(bOffset);
			float cContrib = cGrad.dot(cOffset);
			float dContrib = dGrad.dot(dOffset);

			float xOffsetSq = xOffset * xOffset;
			float yOffsetSq = yOffset * yOffset;

			float xParam = 3 * xOffsetSq - 2 * xOffsetSq * xOffset;
			float yParam = 3 * yOffsetSq - 2 * yOffsetSq * yOffset;

			float abContrib = (1 - xParam) * aContrib + xParam * bContrib;
			float dcContrib = (1 - xParam) * dContrib + xParam * cContrib;

			return (1 - yParam) * abContrib + yParam * dcContrib;
		}

		FloatPoint2 getGradient(const IntPoint2& point) const
		{
			int index = point.y & 255;
			index = (point.x + m_indicies[index]) & 255;

			return m_gradients[index];
		}

	private:

		int* m_indicies;
		FloatPoint2 m_positionOffset;
		FloatPoint2* m_gradients;
	};

	template< typename T >
	class Point3
	{
	public:

		Point3() {};
		Point3(T _x, T _y, T _z) : x(_x), y(_y), z(_z) {}

		T dot(const Point3< T >& other) const
		{
			return x * other.x + y * other.y + z * other.z;
		}

		T x;
		T y;
		T z;
	};

	typedef Point3< int > IntPoint3;
	typedef Point3< float > FloatPoint3;


	class Noise3D
	{
	public:

		Noise3D(int* indicies, FloatPoint3* gradients, FloatPoint3& positionOffset)
			: m_indicies(indicies),
			m_positionOffset(positionOffset),
			m_gradients(gradients) {}

		~Noise3D()
		{
			delete m_indicies;
			delete m_gradients;
		}

		float generate(float x, float y, float z) const
		{
			x += m_positionOffset.x;
			y += m_positionOffset.y;
			z += m_positionOffset.z;

			int xCoord = floor(x);
			int yCoord = floor(y);
			int zCoord = floor(z);

			/*
			Using:
			v ---------- u
			/|           /|
			/ |   (x,y,z)/ |
			/  |  .      /  |
			d ---------- c   |
			|   s -------|-- t
			|  /         |  /
			y     | /          | /
			^  z  |/           |/
			| ¬   a ---------- b
			|/
			---> x

			*/

			IntPoint3 a(xCoord, yCoord, zCoord);
			IntPoint3 b(xCoord + 1, yCoord, zCoord);
			IntPoint3 c(xCoord + 1, yCoord + 1, zCoord);
			IntPoint3 d(xCoord, yCoord + 1, zCoord);

			IntPoint3 s(xCoord, yCoord, zCoord + 1);
			IntPoint3 t(xCoord + 1, yCoord, zCoord + 1);
			IntPoint3 u(xCoord + 1, yCoord + 1, zCoord + 1);
			IntPoint3 v(xCoord, yCoord + 1, zCoord + 1);

			FloatPoint3 aGrad = getGradient(a);
			FloatPoint3 bGrad = getGradient(b);
			FloatPoint3 cGrad = getGradient(c);
			FloatPoint3 dGrad = getGradient(d);

			FloatPoint3 sGrad = getGradient(s);
			FloatPoint3 tGrad = getGradient(t);
			FloatPoint3 uGrad = getGradient(u);
			FloatPoint3 vGrad = getGradient(v);

			float xOffset = x - xCoord;
			float yOffset = y - yCoord;
			float zOffset = z - zCoord;

			FloatPoint3 aOffset(xOffset, yOffset, zOffset);
			FloatPoint3 bOffset(xOffset - 1, yOffset, zOffset);
			FloatPoint3 cOffset(xOffset - 1, yOffset - 1, zOffset);
			FloatPoint3 dOffset(xOffset, yOffset - 1, zOffset);

			FloatPoint3 sOffset(xOffset, yOffset, zOffset - 1);
			FloatPoint3 tOffset(xOffset - 1, yOffset, zOffset - 1);
			FloatPoint3 uOffset(xOffset - 1, yOffset - 1, zOffset - 1);
			FloatPoint3 vOffset(xOffset, yOffset - 1, zOffset - 1);

			float aContrib = aGrad.dot(aOffset);
			float bContrib = bGrad.dot(bOffset);
			float cContrib = cGrad.dot(cOffset);
			float dContrib = dGrad.dot(dOffset);

			float sContrib = sGrad.dot(sOffset);
			float tContrib = tGrad.dot(tOffset);
			float uContrib = uGrad.dot(uOffset);
			float vContrib = vGrad.dot(vOffset);

			float xParam = 3 * xOffset * xOffset - 2 * xOffset * xOffset * xOffset;
			float yParam = 3 * yOffset * yOffset - 2 * yOffset * yOffset * yOffset;
			float zParam = 3 * zOffset * zOffset - 2 * zOffset * zOffset * zOffset;

			float abContrib = (1 - xParam) * aContrib + xParam * bContrib;
			float dcContrib = (1 - xParam) * dContrib + xParam * cContrib;

			float stContrib = (1 - xParam) * sContrib + xParam * tContrib;
			float vuContrib = (1 - xParam) * vContrib + xParam * uContrib;

			float abcdContrib = (1 - yParam) * abContrib + yParam * dcContrib;
			float stuvContrib = (1 - yParam) * stContrib + yParam * vuContrib;

			return (1 - zParam) * abcdContrib + zParam * stuvContrib;
		}

		FloatPoint3 getGradient(IntPoint3 point) const
		{
			int index = point.z & 255;
			index = (point.y + m_indicies[index]) & 255;
			index = (point.x + m_indicies[index]) & 255;

			return m_gradients[index];
		}

	private:

		int* m_indicies;
		FloatPoint3 m_positionOffset;
		FloatPoint3* m_gradients;

	};


	class NoiseFactory
	{
	public:

		NoiseFactory()
		{
			srand((unsigned) time(NULL));
		};


		Noise1D* create1D() const
		{
			float* gradients = new float[256];

			for(int i = 0; i<256; ++i)
			{
				gradients[i] = rand() > 0.5 ? 1.0 : -1.0;
			}

			/*
			Offsets as generated by the following python code:

			import random
			values = [ str( x ) for x in range( 0, 256 ) ]
			random.seed( 0 )
			random.shuffle( values )
			print "{ %s }" % ", ".join( values )

			*/
			int P[256] = { 62, 211, 5, 167, 9, 20, 189, 30, 224, 93, 176, 110,
				155, 214, 50, 238, 81, 114, 104, 90, 151, 169, 160, 103, 197, 66,
				89, 85, 127, 55, 201, 172, 141, 10, 92, 70, 44, 163, 217, 212, 209,
				7, 125, 57, 36, 237, 254, 142, 97, 153, 227, 61, 27, 8, 146, 115,
				244, 173, 240, 252, 202, 162, 236, 56, 24, 42, 205, 135, 175, 215,
				74, 29, 198, 122, 46, 48, 188, 79, 88, 190, 77, 19, 251, 138, 206,
				63, 1, 133, 233, 140, 32, 28, 170, 53, 38, 45, 180, 43, 59, 25,
				184, 181, 69, 168, 255, 71, 18, 229, 204, 80, 39, 22, 152, 11, 131,
				245, 145, 41, 178, 249, 31, 12, 134, 132, 117, 100, 26, 15, 230,
				124, 2, 4, 154, 148, 52, 78, 83, 239, 220, 177, 248, 129, 82, 6,
				250, 199, 14, 182, 207, 119, 33, 17, 111, 37, 130, 166, 76, 96, 13,
				126, 147, 174, 196, 235, 95, 157, 98, 150, 143, 137, 47, 221, 67,
				94, 161, 226, 241, 164, 156, 136, 203, 86, 120, 191, 34, 35, 54,
				108, 72, 113, 84, 112, 116, 186, 105, 232, 225, 228, 231, 21, 187,
				102, 64, 16, 91, 165, 200, 49, 247, 40, 242, 243, 51, 185, 253, 0,
				246, 222, 87, 158, 3, 121, 179, 58, 194, 107, 219, 208, 139, 99,
				23, 109, 159, 210, 171, 73, 213, 192, 234, 218, 60, 149, 183, 68,
				123, 223, 144, 118, 75, 195, 101, 128, 65, 106, 193, 216 };

			int* indicies = new int[256];

			memcpy(indicies, P, sizeof(int) * 256);

			return new Noise1D(indicies, gradients, gradients[0]);
		}


		Noise2D* create2D() const
		{
			FloatPoint2* gradients = new FloatPoint2[256];

			for(int i = 0; i<256; ++i)
			{
				gradients[i].x = rand() * 2.0 - 1.0;
				gradients[i].y = rand() * 2.0 - 1.0;

				float lengthSq = gradients[i].x * gradients[i].x + gradients[i].y * gradients[i].y;
				float length = sqrt(lengthSq);

				gradients[i].x /= length;
				gradients[i].y /= length;
			}

			/*
			Offsets as generated by the following python code:

			import random
			values = [ str( x ) for x in range( 0, 256 ) ]
			random.seed( 0 )
			random.shuffle( values )
			print "{ %s }" % ", ".join( values )

			*/
			int P[256] = { 62, 211, 5, 167, 9, 20, 189, 30, 224, 93, 176, 110,
				155, 214, 50, 238, 81, 114, 104, 90, 151, 169, 160, 103, 197, 66,
				89, 85, 127, 55, 201, 172, 141, 10, 92, 70, 44, 163, 217, 212, 209,
				7, 125, 57, 36, 237, 254, 142, 97, 153, 227, 61, 27, 8, 146, 115,
				244, 173, 240, 252, 202, 162, 236, 56, 24, 42, 205, 135, 175, 215,
				74, 29, 198, 122, 46, 48, 188, 79, 88, 190, 77, 19, 251, 138, 206,
				63, 1, 133, 233, 140, 32, 28, 170, 53, 38, 45, 180, 43, 59, 25,
				184, 181, 69, 168, 255, 71, 18, 229, 204, 80, 39, 22, 152, 11, 131,
				245, 145, 41, 178, 249, 31, 12, 134, 132, 117, 100, 26, 15, 230,
				124, 2, 4, 154, 148, 52, 78, 83, 239, 220, 177, 248, 129, 82, 6,
				250, 199, 14, 182, 207, 119, 33, 17, 111, 37, 130, 166, 76, 96, 13,
				126, 147, 174, 196, 235, 95, 157, 98, 150, 143, 137, 47, 221, 67,
				94, 161, 226, 241, 164, 156, 136, 203, 86, 120, 191, 34, 35, 54,
				108, 72, 113, 84, 112, 116, 186, 105, 232, 225, 228, 231, 21, 187,
				102, 64, 16, 91, 165, 200, 49, 247, 40, 242, 243, 51, 185, 253, 0,
				246, 222, 87, 158, 3, 121, 179, 58, 194, 107, 219, 208, 139, 99,
				23, 109, 159, 210, 171, 73, 213, 192, 234, 218, 60, 149, 183, 68,
				123, 223, 144, 118, 75, 195, 101, 128, 65, 106, 193, 216 };

			int* indicies = new int[256];

			memcpy(indicies, P, sizeof(int) * 256);

			return new Noise2D(indicies, gradients, gradients[0]);
		}


		std::unique_ptr<Noise3D> create3D() const
		{
			FloatPoint3* gradients = new FloatPoint3[256];

			for(int i = 0; i<256; ++i)
			{
				gradients[i].x = rand() * 2.0 - 1.0;
				gradients[i].y = rand() * 2.0 - 1.0;
				gradients[i].z = rand() * 2.0 - 1.0;

				float lengthSq = gradients[i].x * gradients[i].x
					+ gradients[i].y * gradients[i].y
					+ gradients[i].z * gradients[i].z;
				float length = sqrt(lengthSq);

				gradients[i].x /= length;
				gradients[i].y /= length;
				gradients[i].z /= length;
			}

			/*
			Offsets as generated by the following python code:

			import random
			values = [ str( x ) for x in range( 0, 256 ) ]
			random.seed( 0 )
			random.shuffle( values )
			print "{ %s }" % ", ".join( values )

			*/
			int P[256] = { 62, 211, 5, 167, 9, 20, 189, 30, 224, 93, 176, 110,
				155, 214, 50, 238, 81, 114, 104, 90, 151, 169, 160, 103, 197, 66,
				89, 85, 127, 55, 201, 172, 141, 10, 92, 70, 44, 163, 217, 212, 209,
				7, 125, 57, 36, 237, 254, 142, 97, 153, 227, 61, 27, 8, 146, 115,
				244, 173, 240, 252, 202, 162, 236, 56, 24, 42, 205, 135, 175, 215,
				74, 29, 198, 122, 46, 48, 188, 79, 88, 190, 77, 19, 251, 138, 206,
				63, 1, 133, 233, 140, 32, 28, 170, 53, 38, 45, 180, 43, 59, 25,
				184, 181, 69, 168, 255, 71, 18, 229, 204, 80, 39, 22, 152, 11, 131,
				245, 145, 41, 178, 249, 31, 12, 134, 132, 117, 100, 26, 15, 230,
				124, 2, 4, 154, 148, 52, 78, 83, 239, 220, 177, 248, 129, 82, 6,
				250, 199, 14, 182, 207, 119, 33, 17, 111, 37, 130, 166, 76, 96, 13,
				126, 147, 174, 196, 235, 95, 157, 98, 150, 143, 137, 47, 221, 67,
				94, 161, 226, 241, 164, 156, 136, 203, 86, 120, 191, 34, 35, 54,
				108, 72, 113, 84, 112, 116, 186, 105, 232, 225, 228, 231, 21, 187,
				102, 64, 16, 91, 165, 200, 49, 247, 40, 242, 243, 51, 185, 253, 0,
				246, 222, 87, 158, 3, 121, 179, 58, 194, 107, 219, 208, 139, 99,
				23, 109, 159, 210, 171, 73, 213, 192, 234, 218, 60, 149, 183, 68,
				123, 223, 144, 118, 75, 195, 101, 128, 65, 106, 193, 216 };

			int* indicies = new int[256];

			memcpy(indicies, P, sizeof(int) * 256);

			return std::make_unique<Noise3D>(indicies, gradients, gradients[0]);
		}

	};


}; // end namespace perlin 

#endif // PERLIN_H